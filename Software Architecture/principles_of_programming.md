# Principles of Programming

## 前提

### :bulb: Code as design
- プログラミングは「設計行為」
- コードには、「How」「What」。ドキュメントには「Why」。

### :bulb: Code will be changed
- コードが変更されるという事実は、様々な判断において最優先考慮事項
- 要求の変化はユーザー自身の変化より、ユーザーのビジネス環境の変化による
- **「変更に強いコード」=「読みやすいコード」を書く**

## 原則

### :bulb: KISS - Keep It Simple, Stupid
- 単純性、簡潔性 → **修正容易性**
- できるだけシンプルに

### :bulb: DRY - Don't Repeat Yourself
- コードの重複はコピペによってもたらされる
- 単なるコードの説明をしているコメントも重複に当たる
- 抽象化（関数化、モジュール化）によってロジックを人纏りに

### :bulb: YAGNI - You Aren't Going to Neet It
- 必要な時、必要なコードのみを書く
- 「汎用性」＜「単純性」

### :bulb: PIE - Program Intently and Expressively
- コードの意図がストレートに伝わるように
- コードが最もソフトウェアの挙動を説明する
- 「コードを書く時間、機会」＜「コードを読む時間、機会」
- コメントで「Why」を記述

### :bulb: SLAP - Single Level of Abstraction Principle
- 関数、モジュールを抽象レベルに沿って分割し統一
- コードに「要約性」と「閲覧性」を
- 抽象クラスに高いレベル、景勝クラスに低いレベルの概念を
- 「具体的な処理を書く作業」と「抽象化レベルを揃える作業」を分けて取り組む

### :bulb: OCP - Open-Closed Principle
- コードは「振る舞いを拡張」出来て、「振る舞いの拡張が他に影響を与えない」設計に
- モジュール間のやり取りを、インターフェースに媒介させる

### :bulb: Naming is important
- 適切な命名が出来ない = 設計の中でその要素の役割が曖昧
- 重要なコミュニケーション、ユーザーインターフェース
- 「効果」「目的」を明確に
- 誤解の余地がない、検索可能な名前に

## 思想

### :bulb: プログラミングセオリー
- 「最高のコード」＝「拡張方法が多く存在し、余分な要素が存在せず、読みやすく理解しやすいコード」
- 最高のコード実現の為のセオリーを支える「価値」
  - コミュニケーション
  - シンプル
  - 柔軟性
- 「価値」＝「判断基準」
  - 解決策が満たすべき「要件」
  - 課題に含まれている「制約」
  - 解決策に含まれる「特性」
- 「価値」と「プログラミング」を結ぶ原則
  - 結果の局所化
  - 対称性
  - 繰り返しの最小化
  - 宣言型の表現
  - ロジックとデータの一体化
  - 変更頻度

### :bulb: プログラミングセオリー：結果の局所化
- 変更の影響が最小限に留まるように
- コミュニケーションが円滑に
- 関連性の高低によって依存性を決定

### :bulb: プログラミングセオリー：繰り返しの最小化
- 修正の影響の局所化
- コードを分割して管理 → 共通項を導く

### :bulb: プログラミングセオリー：ロジックとデータの一体化
- ロジックとロジックが操作するデータは極力近くに
- ロジックとデータは修正タイミングが同じ

### :bulb: プログラミングセオリー：対称性
- 一貫性
  - 追加メソッド ⇄ 削除メソッド
  - グループ内関数の引数の統一
  - モジュール内のデータは生存期間を統一
  - 関数内で呼び出す関数の抽象度の統一

### :bulb: 宣言型の表現
- 「命令型」＜「宣言型」
- 宣言型＝解くべき問題の性質、満たすべき制約

### :bulb: 変更頻度
- 変更タイミングが同じ要素は同じグループに
- 変更理由を複数持つ要素は分解
- Single Responsibility Principle

### :bulb: アーキテクチャ根底技法
- モジュールの設計方針、基礎原理
  - 抽象
  - カプセル化
  - 情報隠蔽
  - パッケージ化
  - 関心の分離
  - 充足性、完全性、プリミティブ性
  - ポリシーと実装の分離
  - インターフェースと実装の分離
  - 参照の一点性
  - 分割統治

### :bulb: アーキテクチャ根底技法：抽象
- 捨象 + 一般化
- 捨象：複雑な対象の性質をいくつか捨て去り、特定の性質に目を向けること
- 一般化：具体的な対象から共通の性質を抽出し、より汎用的な概念に定式化すること
- 複雑な対象への効率的なアプローチ
- 複数の異なる対象へのアプローチ

### :bulb: アーキテクチャ根底技法：カプセル化
- 関連のあるデータとロジックを１つのモジュールに
- 変更の影響がモジュール内に留まる
- 再利用性が高まる
- 分割統治

### :bulb: アーキテクチャ根底技法：情報隠蔽
- モジュールの実装をクライアントから隠蔽
- インターフェースを通じたやりとりがシンプル
- モジュール間の線引きが明確に

### :bulb: アーキテクチャ根底技法：パッケージ化
- 関連のあるモジュールをまとめ、ソフトウェア全体を意味のある単位に分割
- ボトムアップで設計

### :bulb: アーキテクチャ根底技法：関心の分離
- 「関心」＝ 機能、目的
- 関心ごとにコードをまとめ、モジュール化

### :bulb: アーキテクチャ根底技法：充足性、完全性、プリミティブ性
- モジュールの担っている中傷の表現は「十分」で、「完全」で「純粋」であるべき
- モジュールが表現している抽象は、正確に意図が伝わらなければいけない
- 情報は多すぎず、少なすぎず

### :bulb: アーキテクチャ根底技法：ポリシーと実装の分離
- モジュールは「ポリシー」もしくは「実装」のどちらか１つを表現
  - ポリシー：ビジネスロジック、その他モジュールに対する引数選択
  - 実装：独立したロジック、前提条件は引数で与えられる

### :bulb: アーキテクチャ根底技法：インターフェースと実装の分離
- モジュールは「インターフェース」と「実装」から成る
  - インターフェース：モジュールの機能、使用方法を定義
  - 実装：モジュールの機能を実現するコード、クライアントからアクセス不可
- モジュール同士の呼び出しはインターフェース を通して

### :bulb: アーキテクチャ根底技法：参照の一点性
- モジュールの要素は一度きりの宣言、定義
- 副作用のないプログラミング

### :bulb: アーキテクチャ根底技法：分割統治
- 複雑で大きな問題を、小さな問題に分割し、個別に解決

### :bulb: アーキテクチャ非機能要件
- 変更用意性、信頼性、テスト容易性など
- 運用、保守に影響大

### :bulb: アーキテクチャ非機能要件：変更容易性
- 保守性：障害対処のしやすさ
- 拡張性：新機能の追加、バージョンアップなど
- 再構築：モジュール間の関係の再組織化
- 移植性：ソフトウェアとその他の要素の適合のしやすさ
- どこが変更されるのか、不変なのか見極める
- 変更される部分は適度な柔軟性を持たせる

### :bulb: アーキテクチャ非機能要件：相互運用性
- 他のソフトウェアとの接続性
- 標準規格の選択

### :bulb: アーキテクチャ非機能要件：効率性
- 効率性
  - 時間効率性：スループット、レスポンスタイム、ターンアラウンドタイム等
  - 資源効率性：CPU使用時間、メモリ使用量、ストレージ消費量、ネットワーク伝送量
- 有限のリソースの適度な利用
- 疎結合性と効率性のバランス

### :bulb: アーキテクチャ非機能要件：信頼性
- 機能を維持する能力
  - フォルトトレランス：障害発生時に正常動作を保ち、復旧する能力
  - ロバストネス：不正な使用、入力からソフトウェアを保護する能力

### :bulb: アーキテクチャ非機能要件：テスト容易性
- 効果的、効率的にテストを行う能力
- 質、カバレッジ、コスト、労力
- テストも考慮した本体設計を

### :bulb: アーキテクチャ非機能要件：再利用性
- 「出来るだけ作らない」→ どこかから借りてくる
- 問題の一般化が必要

### :bulb:　7つの設計原理
- 障害を避ける為のコード構造上の革新観点
- 一定の価値観、観点を持つ

### :bulb:　7つの設計原理：単純原理
- シンプルにこだわる
- 「複雑で全体的な関連性」＜「局所的な完全性」

### :bulb:　7つの設計原理：同型原理
- 形にこだわる → 一貫性
- 同じ事、同じ性質のものは同様に扱う

### :bulb:　7つの設計原理：対称原理
- 形の対称性にこだわる → 予測しやすい
- 条件 ⇄ 反条件 の整合性
- set/get, start/stop, begin/end, push/pop etc...

### :bulb:　7つの設計原理：階層原理
- 階層にこだわる → 可読性
- 物事の、主従関係、前後関係、本末関係
- 一つの階層には同じ抽象レベルのコード

### :bulb:　7つの設計原理：線形原理
- 処理の流れは直線にこだわる → 可読性
- 階層の上位から下位に流れるコード
- 分岐の少ないコード

### :bulb:　7つの設計原理：明証原理
- ロジックの明証性にこだわる
- 骨太なロジックのコード、コメント、ドキュメント

### :bulb:　7つの設計原理：安全原理
- 安全性にこだわる
- あり得ない、想定していないケースも考慮


### :bulb:　UNIX思想：透明性の原則
- ソフトウェアの動作をログなどで可視化する

### :bulb:　UNIX思想：安定性の原則
- 安定性 = 透明性 + 単純性

### :bulb:　UNIX思想：表現性の原則
- 複雑差はデータ側に寄せる → 容易な理解

### :bulb:　UNIX思想：驚き最小の原則
- 意外性を無くす
- 想定ユーザーに既知の情報を考慮
- 伝統を踏襲する

### :bulb:　UNIX思想：沈黙の原則
- 重要な情報のみを表示出力
